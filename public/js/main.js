/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/backo2/index.js":
/*!**************************************!*\
  !*** ./node_modules/backo2/index.js ***!
  \**************************************/
/***/ (() => {

eval("throw new Error(\"Module build failed: Error: ENOENT: no such file or directory, open '/Users/quinn/Dev/IndraAI/repo/DevaUI/node_modules/backo2/index.js'\");\n\n//# sourceURL=webpack://devaui/./node_modules/backo2/index.js?");

/***/ }),

/***/ "./node_modules/component-emitter/index.js":
/*!*************************************************!*\
  !*** ./node_modules/component-emitter/index.js ***!
  \*************************************************/
/***/ (() => {

eval("throw new Error(\"Module build failed: Error: ENOENT: no such file or directory, open '/Users/quinn/Dev/IndraAI/repo/DevaUI/node_modules/component-emitter/index.js'\");\n\n//# sourceURL=webpack://devaui/./node_modules/component-emitter/index.js?");

/***/ }),

/***/ "./node_modules/debug/src/browser.js":
/*!*******************************************!*\
  !*** ./node_modules/debug/src/browser.js ***!
  \*******************************************/
/***/ (() => {

eval("throw new Error(\"Module build failed: Error: ENOENT: no such file or directory, open '/Users/quinn/Dev/IndraAI/repo/DevaUI/node_modules/debug/src/browser.js'\");\n\n//# sourceURL=webpack://devaui/./node_modules/debug/src/browser.js?");

/***/ }),

/***/ "./node_modules/engine.io-client/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/engine.io-client/lib/index.js ***!
  \****************************************************/
/***/ (() => {

eval("throw new Error(\"Module build failed: Error: ENOENT: no such file or directory, open '/Users/quinn/Dev/IndraAI/repo/DevaUI/node_modules/engine.io-client/lib/index.js'\");\n\n//# sourceURL=webpack://devaui/./node_modules/engine.io-client/lib/index.js?");

/***/ }),

/***/ "./node_modules/parseuri/index.js":
/*!****************************************!*\
  !*** ./node_modules/parseuri/index.js ***!
  \****************************************/
/***/ (() => {

eval("throw new Error(\"Module build failed: Error: ENOENT: no such file or directory, open '/Users/quinn/Dev/IndraAI/repo/DevaUI/node_modules/parseuri/index.js'\");\n\n//# sourceURL=webpack://devaui/./node_modules/parseuri/index.js?");

/***/ }),

/***/ "./node_modules/socket.io-parser/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/socket.io-parser/dist/index.js ***!
  \*****************************************************/
/***/ (() => {

eval("throw new Error(\"Module build failed: Error: ENOENT: no such file or directory, open '/Users/quinn/Dev/IndraAI/repo/DevaUI/node_modules/socket.io-parser/dist/index.js'\");\n\n//# sourceURL=webpack://devaui/./node_modules/socket.io-parser/dist/index.js?");

/***/ }),

/***/ "./src/lib/utils.js":
/*!**************************!*\
  !*** ./src/lib/utils.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// Copyright (c)2022 Quinn Michaels. All Rights Reserved.\nconst utils = {\n  logHTML(opts) {\n    if (!opts.text) return;\n    const {type, format, agent, text, data} = opts;\n    const {prompt, profile, key} = agent;\n    const {colors} = prompt;\n    const prompt_color = `rgb(${colors.label.R}, ${colors.label.G}, ${colors.label.B})`;\n    const text_color = `rgb(${colors.text.R}, ${colors.text.G}, ${colors.text.B})`;\n    let theHtml = `\n    <div class=\"log-item ${type} ${format}\">\n      <div class=\"prompt\" style=\"color: ${prompt_color}\"><span class=\"avatar\"><img src=\"${profile.emoji}\"/></span><span class=\"label\">${prompt.text}</span></div>\n      <div class=\"text\" style=\"color: ${text_color}\">${text}</div>\n    </div>`;\n\n    $('#ShellOutput').append(theHtml);\n    utils.logDATA(data)\n\n    return setTimeout(() => {\n      const so = document.getElementById('ShellOutput');\n      if (so) so.scrollTop = so.scrollHeight;\n    },250);\n  },\n  scrollTop(elem) {\n    setTimeout(() => {\n      const so = document.getElementById(elem);\n      so.scrollTop = 0;\n    }, 100);\n  },\n  logBROWSER(opts) {\n    const text = opts.text.replace(/\\n\\r/g, '<br/>').replace(/<div class=\"line\">&gt;<\\/div>/g, '');\n    const styled = opts.html.match(/style=\".+;\"/);\n    if (styled && styled[0]) opts.html = opts.html.replace(styled[0])\n    let theHtml = `<div ${styled && styled[0] ? styled[0] : ''} class=\"browser-item move-in ${opts.meta.method} ${opts.agent.key}\">${opts.html}</div>`;\n    $('#Content .browser-item').removeClass('north south east west up down northwest northeast southwest southeast move-in').addClass(`move-out ${opts.meta.method}`);\n    setTimeout(() => {\n      $('#Content').html(theHtml);\n      utils.scrollTop('Content');\n    }, 950)\n    return true;\n  },\n  logDATA(data) {\n    let theHtml;\n    if (!data) return;\n\n    switch (data.meta.key) {\n      case 'artist':\n        theHtml = [\n          '<h1>Artist Card</h1>',\n          `<div class=\"artist-card\"><img src=\"data:image/png;base64,${data.image}\" alt=\"\" /></div>`\n        ]\n        $('#Content').html(`<div class=\"browser-item artist card\">${theHtml.join('')}</div>`)\n        return;\n      default:\n    }\n  },\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (utils);\n\n\n//# sourceURL=webpack://devaui/./src/lib/utils.js?");

/***/ }),

/***/ "./src/ui/index.js":
/*!*************************!*\
  !*** ./src/ui/index.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/utils */ \"./src/lib/utils.js\");\n/* harmony import */ var socket_io_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! socket.io-client */ \"./node_modules/socket.io-client/wrapper.mjs\");\n// Copyright (c)2022 Quinn Michaels\n\n\n\n\nconst emojis = {\n  weather:'üå¶',\n  get:'‚è¨',\n  put: '‚è´',\n  key: 'üîë',\n  eat: 'ü•ó',\n  drink:'ü•õ',\n  pos: 'üöπ',\n  exp: 'ü™ñ',\n  gold: 'üí∞',\n  depart: 'üö∂',\n  arrive: 'üö∂',\n  player: 'üßë',\n  alert: 'üö®',\n  trigger: 'üî´',\n  save: 'üíæ',\n  light: 'üî¶',\n  wield: 'üî™',\n  head: 'üß¢',\n  legs: 'ü¶ø',\n  feet: 'ü•æ',\n  hands: '‚úã',\n  waist: 'ü•ã',\n  rwrist: 'üëâ',\n  lwrist: 'üëà',\n  body: 'üëï',\n  arms: 'ü¶æ',\n  shield: 'üõ°',\n  about: 'üéí',\n  say: 'üí¨',\n  door: 'üö™',\n  info: 'üíÅ',\n  error: '‚ùå',\n  fight: 'ü•ä',\n  sound: 'üîä'\n};\n\nclass DevaInterface {\n  constructor() {\n    this.client = false;\n    this.content = false;\n    this.data = false;\n    this.log = [];\n    this.socket = false;\n    this.editing = false;\n    this.viewing = false;\n    this.viewed = false;\n    this.state = 'terminal';\n    this.state_prev = false;\n    this.adventure = false;\n    this.room = false;        // set the current room mud game.\n    this.map = false;\n    this.console = [];        // used for keeping track of items in the console.\n  }\n\n  _insertLog(log) {\n    this.log.push(log);\n  }\n\n  // the keyvalue pair processor for output into html of recursive structures.\n  _keyValue(obj) {\n    // create html key pair format\n    const output = [];\n    for (let key in obj) {\n      const v = obj[key];\n      if (typeof v === 'object') {\n        output.push(`<div class=\"child\"><div class=\"key\">${key}</div><div class=\"values\">${this._keyValue(v)}</div></div>`);\n      }\n      else if(Array.isArray(v)) {\n        v.forEach((av,idx) => {\n          output.push(`<div class=\"row\"><div class=\"value\">${idx}. ${av}</div></div>`);\n        });\n      }\n      else {\n        let _temp = v;\n        if (_temp && _temp.toString().startsWith('/')) _temp = `<button class=\"jump\" data-data=\"${v}\">${v}</button>`;\n        output.push(`<div class=\"row\"><div class=\"key\">${key}:</div><div class=\"value\">${_temp}</div></div>`);\n      };\n    }\n    return output.join('\\n');\n  }\n\n  _setState(state) {\n    $('body').removeClass(this.state).addClass(state);\n    this.state_prev = this.state;\n    this.state = state;\n  }\n\n  _console(key,value) {\n    if (this.console.length > 20) {\n      this.console = [];\n      $('#MudConsole').html('');\n    }\n    this.console.push({key,value});\n    $('#MudConsole').prepend(`<div class=\"item ${key.toLowerCase()}\">${emojis[key.toLowerCase()]} ${value}</div>`)\n  }\n\n  Question(q, log=true) {\n    this._insertLog({type:'question', text:q, agent:this.client});\n\n    if (log) _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].logHTML({\n      type: 'question',\n      format: 'terminal',\n      text: q,\n      agent: this.client,\n    });\n\n    return new Promise((resolve, reject) => {\n      this.Clear(q);\n      axios.post('/question', {\n        question: q,\n      }).then(() => {\n        return resolve();\n      }).catch(reject);\n    });\n  }\n\n  Command(text, log=true) {\n    const q = document.getElementById('q');\n    if (!q) return Promise.resolve();\n    q.focus();\n    return this.Question(text, log).catch(console.error);\n  }\n\n  Log() {\n    return Promise.resolve(this._formatLog());\n  }\n\n  // load key value pair objects into the this scope and output to a data container\n  GetKeyPair(opts) {\n    return new Promise((resolve, reject) => {\n      axios.get(opts.path).then(result => {\n        this[opts.var] = result.data.DATA;\n        this.content =`<div class=\"DataContainer\" id=\"${opts.id}\"><h1>${opts.var.toUpperCase()}</h1>${this._keyValue(result.data)}</div>`;\n        return resolve();\n      }).catch(reject);\n    });\n  }\n\n  Client(_path='/data/client.json') {\n    return new Promise((resolve, reject) => {\n      // get the client data and load it into the key value pair this scope.\n      this.GetKeyPair({\n        path: _path,\n        id: 'Client',\n        var: 'client'\n      }).then(result => {\n        // setup the form display for the agent\n        this.Show('client');\n        const shell = document.getElementById('q');\n        const label = document.getElementById('ShellInputLabel');\n        const {prompt} = this.client;\n        const {colors} = prompt;\n        if (shell) {\n          shell.style.color = `rgb(${colors.text.R}, ${colors.text.G}, ${colors.text.B})`;\n        }\n        if (label) {\n          label.style.color = `rgb(${colors.label.R}, ${colors.label.G}, ${colors.label.B})`;\n          label.innerHTML = `${prompt.emoji} ${prompt.text}`;\n        }\n        return resolve(true);\n      });\n    })\n  }\n\n  Data(_path='/data/index.json') {\n    return new Promise((resolve, reject) => {\n      this.GetKeyPair({\n        path: _path,\n        id: 'Data',\n        var: 'data',\n      }).then(result => {\n        this.Show('data');\n      })\n    });\n  }\n\n  Devas(deva='') {\n    return new Promise((resolve, reject) => {\n      this.GetKeyPair({\n        path: `/devas/${deva}`,\n        id: 'DevasData',\n        var: 'devas'\n      }).then(result => {\n        this.Show('devas');\n      }).catch(reject)\n    });\n  }\n\n  View(doc='main') {\n    return new Promise((resolve, reject) => {\n      this.GetFeecting({\n        path: doc,\n        id: 'ViewData',\n        var: 'view',\n      }).then(result => {\n        this.Show('view');\n        return resolve(true);\n      }).catch(reject);\n    })\n  }\n\n  Show(area) {\n    $('#Content').html(this.content);\n    setTimeout(() => {\n      const so = document.getElementById('Content');\n      so.scrollTop = 0;\n    }, 250)\n    return Promise.resolve(true);\n  }\n\n  deva(data) {\n    $('#MudAlerts').prepend(`<div class=\"deva alert\">${data.text}</div>`);\n  }\n\n  // parses coordinates from a string\n  coordinates(txt, adv) {\n    const coord = /coordinates:(.+)\\[(.+)\\|(.+)\\]/g;\n    const coordinates = coord.exec(txt);\n    if (!coordinates) return;\n    const nameS = coordinates[1].split('-');\n    const name = nameS && nameS[1] ? nameS[1] : 'main';\n    const _map = `/asset/${adv}/map/${nameS[0]}/${name}`;\n    if (_map !== this.map) {\n      this.map = _map;\n      $('.controls').css({'background-image': `url(${this.map})`});\n    }\n    $('.controls').css({'background-position': `${coordinates[2]}px ${coordinates[3]}px`});\n    return;\n  }\n\n  patterns(data) {\n    const trigger = data.state.split(':')[0].toLowerCase();\n    const self = this;\n    const triggers = {\n      room(data) {\n        $('#WatchRoom').html(`<span>${data.text}</span>`);\n        return;\n      },\n      bars(opts) {\n        let {bid, bclass, bmin, bmax} = opts;\n        let bar = Math.floor((bmin / bmax) * 100);\n        if (bar > 100) bar = 100\n\n        if (bar < 30) bclass += ' warning';\n        if (bar < 15) bclass += ' alert';\n        $(`#${bid} .bar`).removeClass('warning').removeClass('alert').addClass(bclass).attr('style', `--bar-width: ${bar}%;`);\n      },\n      hit(data) {\n        this.bars({\n          bid: 'MudStatsHit',\n          bclass: 'hit',\n          bmin: data.pattern.matched[2],\n          bmax: data.pattern.matched[3],\n        });\n      },\n      mana(data) {\n        this.bars({\n          bid: 'MudStatsMana',\n          bclass: 'mana',\n          bmin: data.pattern.matched[2],\n          bmax: data.pattern.matched[3],\n        });\n      },\n\n      move(data) {\n        this.bars({\n          bid: 'MudStatsMove',\n          bclass: 'mana',\n          bmin: data.pattern.matched[2],\n          bmax: data.pattern.matched[3],\n        });\n      },\n\n      hunger(data) {\n        this.bars({\n          bid: 'MudStatsHunger',\n          bclass: 'hunger',\n          bmin: data.pattern.matched[2],\n          bmax: data.pattern.matched[3],\n        });\n      },\n\n      thirst(data) {\n        this.bars({\n          bid: 'MudStatsThirst',\n          bclass: 'hunger',\n          bmin: data.pattern.matched[2],\n          bmax: data.pattern.matched[3],\n        });\n      },\n\n      equipment(data) {\n        const equip = (/equipment:(.+):(.+)/g).exec(data.text);\n        $('#MudEquipment').append(`<div class=\"item equipment\">${emojis[equip[1].toLowerCase()]} ${equip[2]}</div>`);\n      },\n\n      inventory(data) {\n        $('#MudInventory').append(`<div class=\"item inventory\">${data.pattern.matched[2]}</div>`);\n      },\n\n      current(data) {\n        $('#q').val(data.text.replace(/\\ncurrent:\\s?(.+)/, `#mud > $1`));\n        document.getElementById('q').focus();\n      },\n\n      fight(data) {\n        const {matched} = data.pattern;\n        $('#MudAlerts').prepend(`<div class=\"item fight\">${emojis[matched[1].toLowerCase()]} ${matched[2]}</div>`);\n      },\n\n      save(data) {\n        $('#ShellOutput').html('')\n        const {matched} = data.pattern;\n        return self._console(matched[1],matched[2]);\n      },\n\n      info(data) {\n        const {matched} = data.pattern;\n        return self._console(matched[1],matched[2]);\n      },\n\n      error(data) {\n        const {matched} = data.pattern;\n        return self._console(matched[1],matched[2]);\n      },\n\n      alert(data) {\n        const {matched} = data.pattern;\n        return self._console(matched[1],matched[2]);\n      },\n      door(data) {\n        const {matched} = data.pattern;\n        return self._console(matched[1],matched[2]);\n      },\n      player(data) {\n        const {matched} = data.pattern;\n        return self._console(matched[1],matched[2]);\n      },\n      arrive(data) {\n        const {matched} = data.pattern;\n        return self._console(matched[1],matched[2]);\n      },\n      depart(data) {\n        const {matched} = data.pattern;\n        return self._console(matched[1],matched[2]);\n      },\n      gold(data) {\n        const {matched} = data.pattern;\n        return self._console(matched[1],matched[2]);\n      },\n      exp(data) {\n        const {matched} = data.pattern;\n        return self._console(matched[1],matched[2]);\n      },\n      pos(data) {\n        const {matched} = data.pattern;\n        return self._console(matched[1],matched[2]);\n      },\n      key(data) {\n        const {matched} = data.pattern;\n        return self._console(matched[1],matched[2]);\n      },\n      drink(data) {\n        const {matched} = data.pattern;\n        return self._console(matched[1],matched[2]);\n      },\n      eat(data) {\n        const {matched} = data.pattern;\n        return self._console(matched[1],matched[2]);\n      },\n      put(data) {\n        const {matched} = data.pattern;\n        return self._console(matched[1],matched[2]);\n      },\n      get(data) {\n        const {matched} = data.pattern;\n        return self._console(matched[1],matched[2]);\n      },\n      weather(data) {\n        const {matched} = data.pattern;\n        return self._console(matched[1],matched[2]);\n      },\n      trigger(data) {\n        const {matched} = data.pattern;\n        return self._console(matched[1],matched[2]);\n      },\n      time(data) {\n        const {matched} = data.pattern;\n        const time = matched[2].split(':');\n        const hour = time[0] < 10 ? `0${time[0]}` : time[0];\n        const minute = time[1] < 10 ? `0${time[1]}` : time[1];\n        $('#WatchHour').html(`<span>${hour}:${minute}</span>`);\n      },\n      date(data) {\n        const {matched} = data.pattern;\n        const DoW = matched[2].split(' - ');\n        $('#WatchDay').html(`<span>${DoW[0].trim()}</span>`);\n        $('#WatchDate').html(`<span>${DoW[1].trim()}</span>`);\n      },\n      gui(data) {\n        // split the gui command from string\n        const parse = data.text.split(':');\n        const label = parse.shift();\n        const cmd = parse.length > 1 ? parse.join(':') : parse[0];\n        self.Question(cmd, false);\n      }\n    }\n    if (triggers[trigger] && typeof triggers[trigger] === 'function') return triggers[trigger](data);\n    const split_for_emoji = data.text.split(':');\n    const the_emoji = split_for_emoji.shift().toLowerCase().trim();\n    const _emoji = emojis[the_emoji];\n    if (_emoji) data.text = `${_emoji} ${split_for_emoji.join(':')}`;\n    $('#MudAlerts').prepend(`<div class=\"item alert\">${data.text}</div>`);\n  }\n\n  environment(data) {\n    $('#MudEnvironment').prepend(data.html)\n  }\n\n  navigate(data) {\n    this.Clear();\n    _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].logBROWSER(data);\n    setTimeout(() => {\n      this.Question(`#mud exits`, false);\n    }, 1000);\n  }\n\n  goto(data) {\n    return this.navigate(data);\n  }\n\n  read(data) {\n    $('#Content').html(`<div class=\"browser-item read\">${data.html}</div>`);\n  }\n\n  canvas(data) {\n    _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].logBROWSER(data.a);\n  }\n\n  terminal(data) {\n    _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].logHTML({\n      key:data.meta.key,\n      format: data.meta.format,\n      text:data.html ? data.html : data.text,\n      agent: data.agent || this.client,\n    });\n  }\n\n  twitter(data) {\n    const theHTML = []\n    _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].logHTML({\n      key: data.a.meta.key,\n      format: data.a.meta.method,\n      text: data.a.html || data.a.text,\n      agent:data.a.agent,\n    });\n  }\n\n  reddit(opts) {\n    utls.logBrowser(opts.a);\n  }\n\n  docs(opts) {\n    _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].logBROWSER(opts.a);\n  }\n\n  slab(opts) {\n    console.log(opts);\n    const {meta, html, text, agent} = opts.a;\n\n    if (meta.method === 'tts') {\n      $('#MudAlerts').prepend(`<div class=\"item audio\">${html}</div>`);\n    }\n    else {\n      _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].logHTML({\n        type: meta.key,\n        format: meta.method,\n        agent:agent,\n        meta: meta,\n        text: html ? html : text,\n      });\n    }\n  }\n\n  mud(opts) {\n    const self = this;\n    const {method} = opts.a.meta;\n    const mudder = {\n      help(opts) {\n        const theHTML = `<div class=\"browser-item help\">${opts.html}</div>`;\n        $('#Content').html(theHTML);\n      },\n\n      terminal(opts) {\n        return _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].logHTML({\n          agent: opts.agent,\n          type: opts.meta.key,\n          format: opts.meta.method,\n          text: opts.html ? opts.html : opts.text,\n        });\n      },\n\n      goto(opts) {\n        return this.look(opts);\n      },\n\n      look(opts) {\n        return self.navigate(opts);\n      },\n\n      where(opts) {\n        return _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].logHTML({\n          agent: opts.agent,\n          type: opts.meta.key,\n          format: opts.meta.method,\n          text: opts.html || opts.text,\n        })\n      },\n\n      exits(opts) {\n        const exits = opts.text.split('\\n');\n\n        exits.forEach(ex => {\n          const bt = ex.match(/exit\\[(.+)\\]:(.+)/);\n          if (!bt) return;\n          $(`[data-navigate=\"${bt[1]}\"]`).addClass('active');\n          $(`.btn.exit.${bt[1]} span`).text(bt[2]);\n        });\n        return;\n      },\n      score(data) {\n        $('#MudScore').html(data.html);\n        const service = $('#MudScore .service .value').text();\n        setTimeout(() => {\n          $('body').attr('class', '');\n          $('body').addClass(service);\n        }, 200);\n        return;\n      },\n      north(data) {\n        return self.navigate(data);\n      },\n      northeast(data) {\n        return self.navigate(data);\n      },\n      south(data) {\n        return self.navigate(data);\n      },\n      southeast(data) {\n        return self.navigate(data);\n      },\n      east(data) {\n        return self.navigate(data);\n      },\n      northwest(data) {\n        return self.navigate(data);\n      },\n      west(data) {\n        return self.navigate(data);\n      },\n      southwest(data) {\n        return self.navigate(data);\n      },\n      up(data) {\n        return self.navigate(data);\n      },\n      down(data) {\n        return self.navigate(data);\n      },\n      time(data) {\n        const parts = data.text.split(' | ');\n        if (!parts[1]) return;\n        const T = parts[0].split(':');\n        const D = parts[1].split(':')[1].trim();\n        const DoW = D.split('-')\n\n        const hour = T[1] < 10 ? `0${T[1]}` : T[1];\n        const minute = T[2] < 10 ? `0${T[2]}` : T[2];\n\n        $('#WatchHour').html(`<span>${hour}:${minute}</span>`);\n        $('#WatchDay').html(`<span>${DoW[0].trim()}</span>`);\n        $('#WatchDate').html(`<span>${DoW[1].trim()}</span>`);\n        return;\n      },\n      stat(opts) {\n        return _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].logBROWSER(opts);\n      },\n      play(opts) {\n        return _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].logHTML({\n          type: opts.meta.key,\n          format: opts.meta.format,\n          text: 'FOLLOW UP COMPLETE',\n          agent: this.client,\n        });\n      },\n\n      say(opts) {\n        console.log('SAY OPTS', opts);\n        const split_for_emoji = opts.text.split(':');\n        const the_emoji = split_for_emoji.shift().toLowerCase().trim();\n        const _emoji = emojis[the_emoji];\n        if (_emoji) opts.text = `${_emoji} ${split_for_emoji.join(':')}`;\n        $('#MudAlerts').prepend(`<div class=\"item alert\">${opts.html || opts.text}</div>`);\n      },\n    };\n    // check for auth variable to play mudder\n    if (this.state === 'auth') return mudder.play(opts.a);\n\n    // check the text for coordinate string to move map\n    this.coordinates(opts.a.text, opts.a.meta.adventure.key);\n\n    const strKey = opts.a.text.split(':')[0].replace(/\\n/, '');\n    const strChk = mudder[strKey] && typeof mudder[strKey] === 'function';\n\n    if (strChk) {\n      opts.a.meta.method = strChk;\n      return mudder[strKey](opts.a);\n    }\n\n    const logger = mudder[method] && typeof mudder[method] === 'function';\n    // if the method is a function then return that.\n    if (logger) return mudder[method](opts.a);\n\n    // default return for data not caught by logger check.\n    return _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].logHTML({\n      type: opts.a.meta.key,\n      format: opts.a.meta.method,\n      agent: opts.a.agent,\n      text: opts.a.html || opts.a.text,\n      data: opts.a,\n    });\n  }\n\n  adventure(opts) {\n    _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].logBROWSER(opts.a);\n  }\n\n  processor(data) {\n    if (!data.a.text) return;\n    const metaKey = data.a.meta.key;\n    // here in the processor we want to check for any strings that also match from the first index.\n    const metaChk = this[metaKey] && typeof this[metaKey] === 'function';\n    if (metaChk) return this[data.a.meta.key](data);\n\n\n    // editor\n    if (data.a.meta.method === 'help') _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].logBROWSER(data.a);\n    else _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].logHTML({\n      type: data.a.meta.key,\n      format: data.a.meta.method,\n      agent:data.a.agent,\n      meta: data.a.meta,\n      text: data.a.html ? data.a.html : data.a.text,\n    });\n\n    // if (!data.a.text && !data.a.html) return;\n    // if (!data.a.meta) return this.general(data);\n    // const type = data.a.meta.type ? data.a.meta.type : false;\n    // if (typeof this[type] === 'function') return this[type](data);\n    //\n    // const states = ['connected', 'editor']\n    // if (data.state && states.includes(data.state.key)) this._setState(data.state.key);\n    // if (this.state === 'editor') return this.general(data);\n    //\n    //\n    return true;\n  }\n\n  Clear(q) {\n    const clearing = [\n      '#mud n',\n      '#mud north',\n      '#mud northeast',\n      '#mud ne',\n      '#mud northwest',\n      '#mud nw',\n      '#mud s',\n      '#mud south',\n      '#mud southeast',\n      '#mud se',\n      '#mud southwest',\n      '#mud sw',\n      '#mud e',\n      '#mud east',\n      '#mud w',\n      '#mud west',\n      '#mud u',\n      '#mud up',\n      '#mud d',\n      '#mud down',\n      '#mud look',\n    ];\n    if (!clearing.find(c => c === q)) return Promise.resolve();\n\n    $('#MudAlerts').html('');\n    $('#MudConsole').html(``);\n    $('#MudSystem .systembox').html(``);\n    $('#MudInventory').html(``);\n    $('#MudEquipment').html(``);\n    $('#MudObjects').html(``);\n    $('#ShellOutput').html(``);\n\n\n    $('.dots').removeClass('active');\n    $('.btn.exit').removeClass('active');\n    $('.btn.exit span').html('');\n    $('[data-navigate]').removeClass('active');\n\n    return Promise.resolve();\n  }\n\n  logData(data) {\n    const _html = [\n      `<div class=\"item datalog\">`,\n      this._keyValue(data),\n      `</div>`,\n    ].join('\\n');\n    $('#MudSystem .systembox').prepend(_html);\n  }\n\n  Init(socket) {\n    return new Promise((resolve, reject) => {\n      this.socket = socket;\n\n      $('body').on('click', '.child > .key', e => {\n        $(e.target).toggleClass('open');\n\n      }).on('click', '[data-function]', e => {\n        e.stopPropagation();\n        e.preventDefault();\n        const func = $(e.target).closest('[data-function]').data('function')\n        this[func]();\n\n      }).on('click', '[data-doc]', e => {\n        e.stopPropagation()\n        e.preventDefault();\n        const doc = $(e.target).closest('[data-doc]').data('doc')\n        this.Command(`#docs view ${doc}`, true);\n\n      }).on('click', '[data-view]', e => {\n        e.stopPropagation();\n        e.preventDefault();\n        const view = $(e.target).closest('[data-view]').data('view')\n        this.View(view);\n\n      }).on('click', '[data-cmd]', e => {\n        e.stopPropagation()\n        e.preventDefault();\n        const cmd = $(e.target).closest('[data-cmd]').data('cmd');\n        this.Command(cmd, false);\n\n      // insert tty string into q intpu\n      }).on('click', '[data-tty]', e => {\n        e.stopPropagation()\n        e.preventDefault();\n        const cmd = $(e.target).closest('[data-tty]').data('tty');\n        $('#q').val(cmd);\n        document.getElementById('q').focus();\n\n      // popup modal\n      }).on('click', '[data-pop]', e => {\n        e.stopPropagation()\n        e.preventDefault();\n        const cmd = $(e.target).closest('[data-pop]').data('pop');\n        this.Command(cmd, true);\n\n      }).on('click', '[data-mud]', e => {\n        e.stopPropagation()\n        e.preventDefault();\n        const cmd = $(e.target).closest('[data-mud]').data('mud')\n        this.Command(`#mud ${cmd}`, false);\n\n      }).on('click', '[data-bmud]', e => {\n        e.stopPropagation()\n        e.preventDefault();\n        const cmd = $(e.target).closest('[data-bmud]').data('bmud')\n        this.Command(`#mud > ${cmd}`, false);\n\n      }).on('click', '[data-button]', e => {\n        e.stopPropagation()\n        e.preventDefault();\n        const cmd = $(e.target).closest('[data-button]').data('button')\n        this.Command(cmd, false);\n\n      }).on('click', '[data-data]', e => {\n        e.stopPropagation()\n        e.preventDefault();\n        const data = $(e.target).data('data');\n        this.Data(data);\n\n      }).on('click', '[data-menu]', e => {\n        e.stopPropagation()\n        e.preventDefault();\n        const menu = $(e.target).closest('[data-menu]').data('menu')\n        this.Command(`#mud > ${menu}`, false);\n\n      }).on('click', '[data-navigate]', e => {\n        e.stopPropagation()\n        e.preventDefault();\n        const nav = $(e.target).closest('[data-navigate]').data('navigate');\n        this.Command(`#mud ${nav}`, false);\n\n      }).on('click', '[data-select]', e => {\n        e.stopPropagation()\n        e.preventDefault();\n        this.Command(`#mud > ${e.target.dataset.select}`, false);\n\n      }).on('click', '#Editor .menu[title=\"quit\"]', e=> {\n        e.stopPropagation()\n        e.preventDefault();\n        this._setState('mud');\n        this.Question('#mud look', false)\n\n      }).on('blur', '.editor textarea', e=> {\n        console.log('YOU BLURRED THE TEXT EDITOR', e);\n      });\n\n      $('#Shell').on('submit', e => {\n        e.stopPropagation()\n        e.preventDefault();\n        const question = $('#q').val();\n        this.Question(question).catch(console.error);\n        $('#q').val('');\n      });\n\n      // setup client then trap the system events\n      this.Client().then(() => {\n        socket.emit('client:data', this.client);\n        socket.on('socket:terminal', data => {\n          // log the data packet to the ui\n          if (data.a.data) this.logData({\n            [data.id]: {\n              agent:data.a.agent,\n              client:data.a.client,\n              meta:data.a.meta,\n              data:data.a.data,\n            }\n          });\n          return this.processor(data);\n        })\n        .on('mud:pattern', data => {\n          return this.patterns(data);\n        })\n        .on('mud:exits', data => {\n          console.log('exits', data);\n          return this.exits(data);\n        })\n        .on('mud:time', data => {\n          return this.time(data);\n        });\n\n        return resolve();\n\n      }).catch(reject);\n    });\n  }\n}\n\nconst socket = (0,socket_io_client__WEBPACK_IMPORTED_MODULE_1__.io)('http://localhost:9303');\nconst Deva = new DevaInterface();\nDeva.Init(socket);\n\n\n\n\n\n\n//\n//\n//\n//\n//\n// $('body').on('click', '.child > .key', e => {\n//   $(e.target).toggleClass('open');\n// }).on('click', '#SNACK_TIME > h1', e=> {\n//   $('body').removeClass('snack-time');\n// });\n\n\n//# sourceURL=webpack://devaui/./src/ui/index.js?");

/***/ }),

/***/ "./node_modules/socket.io-client/build/index.js":
/*!******************************************************!*\
  !*** ./node_modules/socket.io-client/build/index.js ***!
  \******************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Socket = exports.io = exports.Manager = exports.protocol = void 0;\nconst url_1 = __webpack_require__(/*! ./url */ \"./node_modules/socket.io-client/build/url.js\");\nconst manager_1 = __webpack_require__(/*! ./manager */ \"./node_modules/socket.io-client/build/manager.js\");\nconst socket_1 = __webpack_require__(/*! ./socket */ \"./node_modules/socket.io-client/build/socket.js\");\nObject.defineProperty(exports, \"Socket\", ({ enumerable: true, get: function () { return socket_1.Socket; } }));\nconst debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\")(\"socket.io-client\");\n/**\n * Module exports.\n */\nmodule.exports = exports = lookup;\n/**\n * Managers cache.\n */\nconst cache = (exports.managers = {});\nfunction lookup(uri, opts) {\n    if (typeof uri === \"object\") {\n        opts = uri;\n        uri = undefined;\n    }\n    opts = opts || {};\n    const parsed = url_1.url(uri, opts.path);\n    const source = parsed.source;\n    const id = parsed.id;\n    const path = parsed.path;\n    const sameNamespace = cache[id] && path in cache[id][\"nsps\"];\n    const newConnection = opts.forceNew ||\n        opts[\"force new connection\"] ||\n        false === opts.multiplex ||\n        sameNamespace;\n    let io;\n    if (newConnection) {\n        debug(\"ignoring socket cache for %s\", source);\n        io = new manager_1.Manager(source, opts);\n    }\n    else {\n        if (!cache[id]) {\n            debug(\"new io instance for %s\", source);\n            cache[id] = new manager_1.Manager(source, opts);\n        }\n        io = cache[id];\n    }\n    if (parsed.query && !opts.query) {\n        opts.query = parsed.queryKey;\n    }\n    return io.socket(parsed.path, opts);\n}\nexports.io = lookup;\n/**\n * Protocol version.\n *\n * @public\n */\nvar socket_io_parser_1 = __webpack_require__(/*! socket.io-parser */ \"./node_modules/socket.io-parser/dist/index.js\");\nObject.defineProperty(exports, \"protocol\", ({ enumerable: true, get: function () { return socket_io_parser_1.protocol; } }));\n/**\n * `connect`.\n *\n * @param {String} uri\n * @public\n */\nexports.connect = lookup;\n/**\n * Expose constructors for standalone build.\n *\n * @public\n */\nvar manager_2 = __webpack_require__(/*! ./manager */ \"./node_modules/socket.io-client/build/manager.js\");\nObject.defineProperty(exports, \"Manager\", ({ enumerable: true, get: function () { return manager_2.Manager; } }));\n\n\n//# sourceURL=webpack://devaui/./node_modules/socket.io-client/build/index.js?");

/***/ }),

/***/ "./node_modules/socket.io-client/build/manager.js":
/*!********************************************************!*\
  !*** ./node_modules/socket.io-client/build/manager.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Manager = void 0;\nconst eio = __webpack_require__(/*! engine.io-client */ \"./node_modules/engine.io-client/lib/index.js\");\nconst socket_1 = __webpack_require__(/*! ./socket */ \"./node_modules/socket.io-client/build/socket.js\");\nconst Emitter = __webpack_require__(/*! component-emitter */ \"./node_modules/component-emitter/index.js\");\nconst parser = __webpack_require__(/*! socket.io-parser */ \"./node_modules/socket.io-parser/dist/index.js\");\nconst on_1 = __webpack_require__(/*! ./on */ \"./node_modules/socket.io-client/build/on.js\");\nconst Backoff = __webpack_require__(/*! backo2 */ \"./node_modules/backo2/index.js\");\nconst debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\")(\"socket.io-client:manager\");\nclass Manager extends Emitter {\n    constructor(uri, opts) {\n        super();\n        this.nsps = {};\n        this.subs = [];\n        if (uri && \"object\" === typeof uri) {\n            opts = uri;\n            uri = undefined;\n        }\n        opts = opts || {};\n        opts.path = opts.path || \"/socket.io\";\n        this.opts = opts;\n        this.reconnection(opts.reconnection !== false);\n        this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);\n        this.reconnectionDelay(opts.reconnectionDelay || 1000);\n        this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);\n        this.randomizationFactor(opts.randomizationFactor || 0.5);\n        this.backoff = new Backoff({\n            min: this.reconnectionDelay(),\n            max: this.reconnectionDelayMax(),\n            jitter: this.randomizationFactor(),\n        });\n        this.timeout(null == opts.timeout ? 20000 : opts.timeout);\n        this._readyState = \"closed\";\n        this.uri = uri;\n        const _parser = opts.parser || parser;\n        this.encoder = new _parser.Encoder();\n        this.decoder = new _parser.Decoder();\n        this._autoConnect = opts.autoConnect !== false;\n        if (this._autoConnect)\n            this.open();\n    }\n    reconnection(v) {\n        if (!arguments.length)\n            return this._reconnection;\n        this._reconnection = !!v;\n        return this;\n    }\n    reconnectionAttempts(v) {\n        if (v === undefined)\n            return this._reconnectionAttempts;\n        this._reconnectionAttempts = v;\n        return this;\n    }\n    reconnectionDelay(v) {\n        var _a;\n        if (v === undefined)\n            return this._reconnectionDelay;\n        this._reconnectionDelay = v;\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);\n        return this;\n    }\n    randomizationFactor(v) {\n        var _a;\n        if (v === undefined)\n            return this._randomizationFactor;\n        this._randomizationFactor = v;\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);\n        return this;\n    }\n    reconnectionDelayMax(v) {\n        var _a;\n        if (v === undefined)\n            return this._reconnectionDelayMax;\n        this._reconnectionDelayMax = v;\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);\n        return this;\n    }\n    timeout(v) {\n        if (!arguments.length)\n            return this._timeout;\n        this._timeout = v;\n        return this;\n    }\n    /**\n     * Starts trying to reconnect if reconnection is enabled and we have not\n     * started reconnecting yet\n     *\n     * @private\n     */\n    maybeReconnectOnOpen() {\n        // Only try to reconnect if it's the first time we're connecting\n        if (!this._reconnecting &&\n            this._reconnection &&\n            this.backoff.attempts === 0) {\n            // keeps reconnection from firing twice for the same reconnection loop\n            this.reconnect();\n        }\n    }\n    /**\n     * Sets the current transport `socket`.\n     *\n     * @param {Function} fn - optional, callback\n     * @return self\n     * @public\n     */\n    open(fn) {\n        debug(\"readyState %s\", this._readyState);\n        if (~this._readyState.indexOf(\"open\"))\n            return this;\n        debug(\"opening %s\", this.uri);\n        this.engine = eio(this.uri, this.opts);\n        const socket = this.engine;\n        const self = this;\n        this._readyState = \"opening\";\n        this.skipReconnect = false;\n        // emit `open`\n        const openSubDestroy = on_1.on(socket, \"open\", function () {\n            self.onopen();\n            fn && fn();\n        });\n        // emit `error`\n        const errorSub = on_1.on(socket, \"error\", (err) => {\n            debug(\"error\");\n            self.cleanup();\n            self._readyState = \"closed\";\n            super.emit(\"error\", err);\n            if (fn) {\n                fn(err);\n            }\n            else {\n                // Only do this if there is no fn to handle the error\n                self.maybeReconnectOnOpen();\n            }\n        });\n        if (false !== this._timeout) {\n            const timeout = this._timeout;\n            debug(\"connect attempt will timeout after %d\", timeout);\n            if (timeout === 0) {\n                openSubDestroy(); // prevents a race condition with the 'open' event\n            }\n            // set timer\n            const timer = setTimeout(() => {\n                debug(\"connect attempt timed out after %d\", timeout);\n                openSubDestroy();\n                socket.close();\n                socket.emit(\"error\", new Error(\"timeout\"));\n            }, timeout);\n            this.subs.push(function subDestroy() {\n                clearTimeout(timer);\n            });\n        }\n        this.subs.push(openSubDestroy);\n        this.subs.push(errorSub);\n        return this;\n    }\n    /**\n     * Alias for open()\n     *\n     * @return self\n     * @public\n     */\n    connect(fn) {\n        return this.open(fn);\n    }\n    /**\n     * Called upon transport open.\n     *\n     * @private\n     */\n    onopen() {\n        debug(\"open\");\n        // clear old subs\n        this.cleanup();\n        // mark as open\n        this._readyState = \"open\";\n        super.emit(\"open\");\n        // add new subs\n        const socket = this.engine;\n        this.subs.push(on_1.on(socket, \"ping\", this.onping.bind(this)), on_1.on(socket, \"data\", this.ondata.bind(this)), on_1.on(socket, \"error\", this.onerror.bind(this)), on_1.on(socket, \"close\", this.onclose.bind(this)), on_1.on(this.decoder, \"decoded\", this.ondecoded.bind(this)));\n    }\n    /**\n     * Called upon a ping.\n     *\n     * @private\n     */\n    onping() {\n        super.emit(\"ping\");\n    }\n    /**\n     * Called with data.\n     *\n     * @private\n     */\n    ondata(data) {\n        this.decoder.add(data);\n    }\n    /**\n     * Called when parser fully decodes a packet.\n     *\n     * @private\n     */\n    ondecoded(packet) {\n        super.emit(\"packet\", packet);\n    }\n    /**\n     * Called upon socket error.\n     *\n     * @private\n     */\n    onerror(err) {\n        debug(\"error\", err);\n        super.emit(\"error\", err);\n    }\n    /**\n     * Creates a new socket for the given `nsp`.\n     *\n     * @return {Socket}\n     * @public\n     */\n    socket(nsp, opts) {\n        let socket = this.nsps[nsp];\n        if (!socket) {\n            socket = new socket_1.Socket(this, nsp, opts);\n            this.nsps[nsp] = socket;\n        }\n        return socket;\n    }\n    /**\n     * Called upon a socket close.\n     *\n     * @param socket\n     * @private\n     */\n    _destroy(socket) {\n        const nsps = Object.keys(this.nsps);\n        for (const nsp of nsps) {\n            const socket = this.nsps[nsp];\n            if (socket.active) {\n                debug(\"socket %s is still active, skipping close\", nsp);\n                return;\n            }\n        }\n        this._close();\n    }\n    /**\n     * Writes a packet.\n     *\n     * @param packet\n     * @private\n     */\n    _packet(packet) {\n        debug(\"writing packet %j\", packet);\n        const encodedPackets = this.encoder.encode(packet);\n        for (let i = 0; i < encodedPackets.length; i++) {\n            this.engine.write(encodedPackets[i], packet.options);\n        }\n    }\n    /**\n     * Clean up transport subscriptions and packet buffer.\n     *\n     * @private\n     */\n    cleanup() {\n        debug(\"cleanup\");\n        this.subs.forEach((subDestroy) => subDestroy());\n        this.subs.length = 0;\n        this.decoder.destroy();\n    }\n    /**\n     * Close the current socket.\n     *\n     * @private\n     */\n    _close() {\n        debug(\"disconnect\");\n        this.skipReconnect = true;\n        this._reconnecting = false;\n        if (\"opening\" === this._readyState) {\n            // `onclose` will not fire because\n            // an open event never happened\n            this.cleanup();\n        }\n        this.backoff.reset();\n        this._readyState = \"closed\";\n        if (this.engine)\n            this.engine.close();\n    }\n    /**\n     * Alias for close()\n     *\n     * @private\n     */\n    disconnect() {\n        return this._close();\n    }\n    /**\n     * Called upon engine close.\n     *\n     * @private\n     */\n    onclose(reason) {\n        debug(\"onclose\");\n        this.cleanup();\n        this.backoff.reset();\n        this._readyState = \"closed\";\n        super.emit(\"close\", reason);\n        if (this._reconnection && !this.skipReconnect) {\n            this.reconnect();\n        }\n    }\n    /**\n     * Attempt a reconnection.\n     *\n     * @private\n     */\n    reconnect() {\n        if (this._reconnecting || this.skipReconnect)\n            return this;\n        const self = this;\n        if (this.backoff.attempts >= this._reconnectionAttempts) {\n            debug(\"reconnect failed\");\n            this.backoff.reset();\n            super.emit(\"reconnect_failed\");\n            this._reconnecting = false;\n        }\n        else {\n            const delay = this.backoff.duration();\n            debug(\"will wait %dms before reconnect attempt\", delay);\n            this._reconnecting = true;\n            const timer = setTimeout(() => {\n                if (self.skipReconnect)\n                    return;\n                debug(\"attempting reconnect\");\n                super.emit(\"reconnect_attempt\", self.backoff.attempts);\n                // check again for the case socket closed in above events\n                if (self.skipReconnect)\n                    return;\n                self.open((err) => {\n                    if (err) {\n                        debug(\"reconnect attempt error\");\n                        self._reconnecting = false;\n                        self.reconnect();\n                        super.emit(\"reconnect_error\", err);\n                    }\n                    else {\n                        debug(\"reconnect success\");\n                        self.onreconnect();\n                    }\n                });\n            }, delay);\n            this.subs.push(function subDestroy() {\n                clearTimeout(timer);\n            });\n        }\n    }\n    /**\n     * Called upon successful reconnect.\n     *\n     * @private\n     */\n    onreconnect() {\n        const attempt = this.backoff.attempts;\n        this._reconnecting = false;\n        this.backoff.reset();\n        super.emit(\"reconnect\", attempt);\n    }\n}\nexports.Manager = Manager;\n\n\n//# sourceURL=webpack://devaui/./node_modules/socket.io-client/build/manager.js?");

/***/ }),

/***/ "./node_modules/socket.io-client/build/on.js":
/*!***************************************************!*\
  !*** ./node_modules/socket.io-client/build/on.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.on = void 0;\nfunction on(obj, ev, fn) {\n    obj.on(ev, fn);\n    return function subDestroy() {\n        obj.off(ev, fn);\n    };\n}\nexports.on = on;\n\n\n//# sourceURL=webpack://devaui/./node_modules/socket.io-client/build/on.js?");

/***/ }),

/***/ "./node_modules/socket.io-client/build/socket.js":
/*!*******************************************************!*\
  !*** ./node_modules/socket.io-client/build/socket.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Socket = void 0;\nconst socket_io_parser_1 = __webpack_require__(/*! socket.io-parser */ \"./node_modules/socket.io-parser/dist/index.js\");\nconst Emitter = __webpack_require__(/*! component-emitter */ \"./node_modules/component-emitter/index.js\");\nconst on_1 = __webpack_require__(/*! ./on */ \"./node_modules/socket.io-client/build/on.js\");\nconst debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\")(\"socket.io-client:socket\");\n/**\n * Internal events.\n * These events can't be emitted by the user.\n */\nconst RESERVED_EVENTS = Object.freeze({\n    connect: 1,\n    connect_error: 1,\n    disconnect: 1,\n    disconnecting: 1,\n    // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener\n    newListener: 1,\n    removeListener: 1,\n});\nclass Socket extends Emitter {\n    /**\n     * `Socket` constructor.\n     *\n     * @public\n     */\n    constructor(io, nsp, opts) {\n        super();\n        this.receiveBuffer = [];\n        this.sendBuffer = [];\n        this.ids = 0;\n        this.acks = {};\n        this.flags = {};\n        this.io = io;\n        this.nsp = nsp;\n        this.ids = 0;\n        this.acks = {};\n        this.receiveBuffer = [];\n        this.sendBuffer = [];\n        this.connected = false;\n        this.disconnected = true;\n        this.flags = {};\n        if (opts && opts.auth) {\n            this.auth = opts.auth;\n        }\n        if (this.io._autoConnect)\n            this.open();\n    }\n    /**\n     * Subscribe to open, close and packet events\n     *\n     * @private\n     */\n    subEvents() {\n        if (this.subs)\n            return;\n        const io = this.io;\n        this.subs = [\n            on_1.on(io, \"open\", this.onopen.bind(this)),\n            on_1.on(io, \"packet\", this.onpacket.bind(this)),\n            on_1.on(io, \"error\", this.onerror.bind(this)),\n            on_1.on(io, \"close\", this.onclose.bind(this)),\n        ];\n    }\n    /**\n     * Whether the Socket will try to reconnect when its Manager connects or reconnects\n     */\n    get active() {\n        return !!this.subs;\n    }\n    /**\n     * \"Opens\" the socket.\n     *\n     * @public\n     */\n    connect() {\n        if (this.connected)\n            return this;\n        this.subEvents();\n        if (!this.io[\"_reconnecting\"])\n            this.io.open(); // ensure open\n        if (\"open\" === this.io._readyState)\n            this.onopen();\n        return this;\n    }\n    /**\n     * Alias for connect()\n     */\n    open() {\n        return this.connect();\n    }\n    /**\n     * Sends a `message` event.\n     *\n     * @return self\n     * @public\n     */\n    send(...args) {\n        args.unshift(\"message\");\n        this.emit.apply(this, args);\n        return this;\n    }\n    /**\n     * Override `emit`.\n     * If the event is in `events`, it's emitted normally.\n     *\n     * @param ev - event name\n     * @return self\n     * @public\n     */\n    emit(ev, ...args) {\n        if (RESERVED_EVENTS.hasOwnProperty(ev)) {\n            throw new Error('\"' + ev + '\" is a reserved event name');\n        }\n        args.unshift(ev);\n        const packet = {\n            type: socket_io_parser_1.PacketType.EVENT,\n            data: args,\n        };\n        packet.options = {};\n        packet.options.compress = this.flags.compress !== false;\n        // event ack callback\n        if (\"function\" === typeof args[args.length - 1]) {\n            debug(\"emitting packet with ack id %d\", this.ids);\n            this.acks[this.ids] = args.pop();\n            packet.id = this.ids++;\n        }\n        const isTransportWritable = this.io.engine &&\n            this.io.engine.transport &&\n            this.io.engine.transport.writable;\n        const discardPacket = this.flags.volatile && (!isTransportWritable || !this.connected);\n        if (discardPacket) {\n            debug(\"discard packet as the transport is not currently writable\");\n        }\n        else if (this.connected) {\n            this.packet(packet);\n        }\n        else {\n            this.sendBuffer.push(packet);\n        }\n        this.flags = {};\n        return this;\n    }\n    /**\n     * Sends a packet.\n     *\n     * @param packet\n     * @private\n     */\n    packet(packet) {\n        packet.nsp = this.nsp;\n        this.io._packet(packet);\n    }\n    /**\n     * Called upon engine `open`.\n     *\n     * @private\n     */\n    onopen() {\n        debug(\"transport is open - connecting\");\n        if (typeof this.auth == \"function\") {\n            this.auth((data) => {\n                this.packet({ type: socket_io_parser_1.PacketType.CONNECT, data });\n            });\n        }\n        else {\n            this.packet({ type: socket_io_parser_1.PacketType.CONNECT, data: this.auth });\n        }\n    }\n    /**\n     * Called upon engine or manager `error`.\n     *\n     * @param err\n     * @private\n     */\n    onerror(err) {\n        if (!this.connected) {\n            super.emit(\"connect_error\", err);\n        }\n    }\n    /**\n     * Called upon engine `close`.\n     *\n     * @param reason\n     * @private\n     */\n    onclose(reason) {\n        debug(\"close (%s)\", reason);\n        this.connected = false;\n        this.disconnected = true;\n        delete this.id;\n        super.emit(\"disconnect\", reason);\n    }\n    /**\n     * Called with socket packet.\n     *\n     * @param packet\n     * @private\n     */\n    onpacket(packet) {\n        const sameNamespace = packet.nsp === this.nsp;\n        if (!sameNamespace)\n            return;\n        switch (packet.type) {\n            case socket_io_parser_1.PacketType.CONNECT:\n                if (packet.data && packet.data.sid) {\n                    const id = packet.data.sid;\n                    this.onconnect(id);\n                }\n                else {\n                    super.emit(\"connect_error\", new Error(\"It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)\"));\n                }\n                break;\n            case socket_io_parser_1.PacketType.EVENT:\n                this.onevent(packet);\n                break;\n            case socket_io_parser_1.PacketType.BINARY_EVENT:\n                this.onevent(packet);\n                break;\n            case socket_io_parser_1.PacketType.ACK:\n                this.onack(packet);\n                break;\n            case socket_io_parser_1.PacketType.BINARY_ACK:\n                this.onack(packet);\n                break;\n            case socket_io_parser_1.PacketType.DISCONNECT:\n                this.ondisconnect();\n                break;\n            case socket_io_parser_1.PacketType.CONNECT_ERROR:\n                const err = new Error(packet.data.message);\n                // @ts-ignore\n                err.data = packet.data.data;\n                super.emit(\"connect_error\", err);\n                break;\n        }\n    }\n    /**\n     * Called upon a server event.\n     *\n     * @param packet\n     * @private\n     */\n    onevent(packet) {\n        const args = packet.data || [];\n        debug(\"emitting event %j\", args);\n        if (null != packet.id) {\n            debug(\"attaching ack callback to event\");\n            args.push(this.ack(packet.id));\n        }\n        if (this.connected) {\n            this.emitEvent(args);\n        }\n        else {\n            this.receiveBuffer.push(Object.freeze(args));\n        }\n    }\n    emitEvent(args) {\n        if (this._anyListeners && this._anyListeners.length) {\n            const listeners = this._anyListeners.slice();\n            for (const listener of listeners) {\n                listener.apply(this, args);\n            }\n        }\n        super.emit.apply(this, args);\n    }\n    /**\n     * Produces an ack callback to emit with an event.\n     *\n     * @private\n     */\n    ack(id) {\n        const self = this;\n        let sent = false;\n        return function (...args) {\n            // prevent double callbacks\n            if (sent)\n                return;\n            sent = true;\n            debug(\"sending ack %j\", args);\n            self.packet({\n                type: socket_io_parser_1.PacketType.ACK,\n                id: id,\n                data: args,\n            });\n        };\n    }\n    /**\n     * Called upon a server acknowlegement.\n     *\n     * @param packet\n     * @private\n     */\n    onack(packet) {\n        const ack = this.acks[packet.id];\n        if (\"function\" === typeof ack) {\n            debug(\"calling ack %s with %j\", packet.id, packet.data);\n            ack.apply(this, packet.data);\n            delete this.acks[packet.id];\n        }\n        else {\n            debug(\"bad ack %s\", packet.id);\n        }\n    }\n    /**\n     * Called upon server connect.\n     *\n     * @private\n     */\n    onconnect(id) {\n        debug(\"socket connected with id %s\", id);\n        this.id = id;\n        this.connected = true;\n        this.disconnected = false;\n        super.emit(\"connect\");\n        this.emitBuffered();\n    }\n    /**\n     * Emit buffered events (received and emitted).\n     *\n     * @private\n     */\n    emitBuffered() {\n        this.receiveBuffer.forEach((args) => this.emitEvent(args));\n        this.receiveBuffer = [];\n        this.sendBuffer.forEach((packet) => this.packet(packet));\n        this.sendBuffer = [];\n    }\n    /**\n     * Called upon server disconnect.\n     *\n     * @private\n     */\n    ondisconnect() {\n        debug(\"server disconnect (%s)\", this.nsp);\n        this.destroy();\n        this.onclose(\"io server disconnect\");\n    }\n    /**\n     * Called upon forced client/server side disconnections,\n     * this method ensures the manager stops tracking us and\n     * that reconnections don't get triggered for this.\n     *\n     * @private\n     */\n    destroy() {\n        if (this.subs) {\n            // clean subscriptions to avoid reconnections\n            this.subs.forEach((subDestroy) => subDestroy());\n            this.subs = undefined;\n        }\n        this.io[\"_destroy\"](this);\n    }\n    /**\n     * Disconnects the socket manually.\n     *\n     * @return self\n     * @public\n     */\n    disconnect() {\n        if (this.connected) {\n            debug(\"performing disconnect (%s)\", this.nsp);\n            this.packet({ type: socket_io_parser_1.PacketType.DISCONNECT });\n        }\n        // remove socket from pool\n        this.destroy();\n        if (this.connected) {\n            // fire events\n            this.onclose(\"io client disconnect\");\n        }\n        return this;\n    }\n    /**\n     * Alias for disconnect()\n     *\n     * @return self\n     * @public\n     */\n    close() {\n        return this.disconnect();\n    }\n    /**\n     * Sets the compress flag.\n     *\n     * @param compress - if `true`, compresses the sending data\n     * @return self\n     * @public\n     */\n    compress(compress) {\n        this.flags.compress = compress;\n        return this;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not\n     * ready to send messages.\n     *\n     * @returns self\n     * @public\n     */\n    get volatile() {\n        this.flags.volatile = true;\n        return this;\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback.\n     *\n     * @param listener\n     * @public\n     */\n    onAny(listener) {\n        this._anyListeners = this._anyListeners || [];\n        this._anyListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback. The listener is added to the beginning of the listeners array.\n     *\n     * @param listener\n     * @public\n     */\n    prependAny(listener) {\n        this._anyListeners = this._anyListeners || [];\n        this._anyListeners.unshift(listener);\n        return this;\n    }\n    /**\n     * Removes the listener that will be fired when any event is emitted.\n     *\n     * @param listener\n     * @public\n     */\n    offAny(listener) {\n        if (!this._anyListeners) {\n            return this;\n        }\n        if (listener) {\n            const listeners = this._anyListeners;\n            for (let i = 0; i < listeners.length; i++) {\n                if (listener === listeners[i]) {\n                    listeners.splice(i, 1);\n                    return this;\n                }\n            }\n        }\n        else {\n            this._anyListeners = [];\n        }\n        return this;\n    }\n    /**\n     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n     * e.g. to remove listeners.\n     *\n     * @public\n     */\n    listenersAny() {\n        return this._anyListeners || [];\n    }\n}\nexports.Socket = Socket;\n\n\n//# sourceURL=webpack://devaui/./node_modules/socket.io-client/build/socket.js?");

/***/ }),

/***/ "./node_modules/socket.io-client/build/url.js":
/*!****************************************************!*\
  !*** ./node_modules/socket.io-client/build/url.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.url = void 0;\nconst parseuri = __webpack_require__(/*! parseuri */ \"./node_modules/parseuri/index.js\");\nconst debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\")(\"socket.io-client:url\");\n/**\n * URL parser.\n *\n * @param uri - url\n * @param path - the request path of the connection\n * @param loc - An object meant to mimic window.location.\n *        Defaults to window.location.\n * @public\n */\nfunction url(uri, path = \"\", loc) {\n    let obj = uri;\n    // default to window.location\n    loc = loc || (typeof location !== \"undefined\" && location);\n    if (null == uri)\n        uri = loc.protocol + \"//\" + loc.host;\n    // relative path support\n    if (typeof uri === \"string\") {\n        if (\"/\" === uri.charAt(0)) {\n            if (\"/\" === uri.charAt(1)) {\n                uri = loc.protocol + uri;\n            }\n            else {\n                uri = loc.host + uri;\n            }\n        }\n        if (!/^(https?|wss?):\\/\\//.test(uri)) {\n            debug(\"protocol-less url %s\", uri);\n            if (\"undefined\" !== typeof loc) {\n                uri = loc.protocol + \"//\" + uri;\n            }\n            else {\n                uri = \"https://\" + uri;\n            }\n        }\n        // parse\n        debug(\"parse %s\", uri);\n        obj = parseuri(uri);\n    }\n    // make sure we treat `localhost:80` and `localhost` equally\n    if (!obj.port) {\n        if (/^(http|ws)$/.test(obj.protocol)) {\n            obj.port = \"80\";\n        }\n        else if (/^(http|ws)s$/.test(obj.protocol)) {\n            obj.port = \"443\";\n        }\n    }\n    obj.path = obj.path || \"/\";\n    const ipv6 = obj.host.indexOf(\":\") !== -1;\n    const host = ipv6 ? \"[\" + obj.host + \"]\" : obj.host;\n    // define unique id\n    obj.id = obj.protocol + \"://\" + host + \":\" + obj.port + path;\n    // define href\n    obj.href =\n        obj.protocol +\n            \"://\" +\n            host +\n            (loc && loc.port === obj.port ? \"\" : \":\" + obj.port);\n    return obj;\n}\nexports.url = url;\n\n\n//# sourceURL=webpack://devaui/./node_modules/socket.io-client/build/url.js?");

/***/ }),

/***/ "./node_modules/socket.io-client/wrapper.mjs":
/*!***************************************************!*\
  !*** ./node_modules/socket.io-client/wrapper.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Manager\": () => (/* binding */ Manager),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"io\": () => (/* reexport default export from named module */ _build_index_js__WEBPACK_IMPORTED_MODULE_0__)\n/* harmony export */ });\n/* harmony import */ var _build_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./build/index.js */ \"./node_modules/socket.io-client/build/index.js\");\n\n\nconst Manager = _build_index_js__WEBPACK_IMPORTED_MODULE_0__.Manager;\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_build_index_js__WEBPACK_IMPORTED_MODULE_0__);\n\n\n//# sourceURL=webpack://devaui/./node_modules/socket.io-client/wrapper.mjs?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/ui/index.js");
/******/ 	
/******/ })()
;